#!/usr/bin/env python3
"""
Script to safely improve C++ code generated by migration scripts.
Only applies safe transformations to avoid compilation errors.
"""

import os
import re
import sys
from pathlib import Path


def safe_improve_cpp_code(content):
    """Apply only safe improvements to make the code more idiomatic."""
    lines = content.split('\n')
    improved_lines = []
    i = 0
    
    while i < len(lines):
        line = lines[i].rstrip()
        
        # Pattern 1: Simple variable declarations that can be made const
        # Only handle cases where variable is declared and immediately assigned
        # and never reassigned in the same scope
        var_decl_match = re.match(r'(\s*)(auto|chain::\w+|\w+::\w+|\w+)\s+(\w+)\s*;', line)
        if (var_decl_match and 'const' not in line and 
            i + 1 < len(lines)):
            
            indent, var_type, var_name = var_decl_match.groups()
            next_line = lines[i + 1].strip()
            
            # Check if the next line is an assignment to this variable
            assignment_match = re.match(rf'(\s*){re.escape(var_name)}\s*=\s*(.+);', next_line)
            if assignment_match:
                assign_indent, value = assignment_match.groups()
                
                # Look ahead in a limited scope to see if this variable is reassigned
                # Only look within the current test case
                reassigned = False
                j = i + 2
                test_end = False
                while j < len(lines) and not test_end:
                    line_text = lines[j].strip()
                    if line_text.startswith('TEST_CASE(') or line_text.startswith('}'):
                        test_end = True
                        break
                    if (f'{var_name} =' in line_text and 
                        'REQUIRE(' not in line_text and 
                        '==' not in line_text and 
                        '!=' not in line_text):
                        reassigned = True
                        break
                    j += 1
                
                # If not reassigned, combine declaration and assignment with const
                if not reassigned:
                    if var_type == 'auto':
                        improved_lines.append(f"{indent}auto const {var_name} = {value};")
                    else:
                        improved_lines.append(f"{indent}{var_type} const {var_name} = {value};")
                    
                    i += 1  # Skip the assignment line
                    continue
        
        # Pattern 2: Auto variable declarations that can be made const
        # Only if they're not reassigned later
        auto_assign_match = re.match(r'(\s*)auto\s+(\w+)\s*=\s*(.+);', line)
        if auto_assign_match and 'const' not in line:
            indent, var_name, value = auto_assign_match.groups()
            
            # Look ahead in a limited scope to see if this variable is reassigned
            reassigned = False
            j = i + 1
            test_end = False
            while j < len(lines) and not test_end:
                line_text = lines[j].strip()
                if line_text.startswith('TEST_CASE(') or line_text.startswith('}'):
                    test_end = True
                    break
                if (f'{var_name} =' in line_text and 
                    'REQUIRE(' not in line_text and 
                    '==' not in line_text and 
                    '!=' not in line_text):
                    reassigned = True
                    break
                j += 1
            
            # If not reassigned, make it const
            if not reassigned:
                line = f"{indent}auto const {var_name} = {value};"
        
        # Pattern 3: Remove unnecessary variable declarations followed by move assignment
        # Example: chain::output instance; instance = create<...>(...);
        # becomes: auto const instance = create<...>(...);
        type_decl_match = re.match(r'(\s*)(chain::\w+|\w+::\w+)\s+(\w+)\s*;', line)
        if (type_decl_match and i + 1 < len(lines)):
            indent, var_type, var_name = type_decl_match.groups()
            next_line = lines[i + 1].strip()
            
            # Check if the next line assigns to this variable with create<> or similar
            create_assign_match = re.match(rf'(\s*){re.escape(var_name)}\s*=\s*(create<.+>|std::move|[^=]+);', next_line)
            if create_assign_match:
                assign_indent, value = create_assign_match.groups()
                
                # Look ahead to see if this variable is reassigned later
                reassigned = False
                j = i + 2
                test_end = False
                while j < len(lines) and not test_end:
                    line_text = lines[j].strip()
                    if line_text.startswith('TEST_CASE(') or line_text.startswith('}'):
                        test_end = True
                        break
                    if (f'{var_name} =' in line_text and 
                        'REQUIRE(' not in line_text and 
                        '==' not in line_text and 
                        '!=' not in line_text):
                        reassigned = True
                        break
                    j += 1
                
                # If not reassigned, combine into single const declaration
                if not reassigned:
                    improved_lines.append(f"{indent}auto const {var_name} = {value};")
                    i += 1  # Skip the assignment line
                    continue
        
        improved_lines.append(line)
        i += 1
    
    return '\n'.join(improved_lines)


def process_file(file_path):
    """Process a single C++ file to improve its code safely."""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        improved_content = safe_improve_cpp_code(content)
        
        # Only write if there are changes
        if improved_content != content:
            # Create backup
            backup_path = str(file_path) + '.backup2'
            with open(backup_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            # Write improved content
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(improved_content)
            
            print(f"Safely improved: {file_path}")
            return True
        else:
            print(f"No safe changes: {file_path}")
            return False
    
    except Exception as e:
        print(f"Error processing {file_path}: {e}")
        return False


def main():
    """Main function to process specific files or all test files."""
    if len(sys.argv) > 1:
        # Process specific files
        files_to_process = sys.argv[1:]
    else:
        print("Usage: python3 safe_improve_code.py <file1> <file2> ...")
        return
    
    processed_count = 0
    improved_count = 0
    
    for file_path in files_to_process:
        processed_count += 1
        if process_file(file_path):
            improved_count += 1
    
    print(f"\nProcessed {processed_count} files, safely improved {improved_count} files")
    if improved_count > 0:
        print("Backup files created with .backup2 extension")


if __name__ == "__main__":
    main()
