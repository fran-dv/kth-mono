#!/usr/bin/env python3
"""
Script to improve the C++ code generated by migration scripts.
Makes the code more idiomatic and efficient by:
1. Making byte_reader const when appropriate
2. Making variables const when they're not reassigned
3. Combining declaration and initialization where possible
4. Removing unnecessary temporary variables
5. Improving patterns like direct initialization
"""

import os
import re
import sys
from pathlib import Path


def improve_cpp_code(content):
    """Apply various improvements to make the code more idiomatic."""
    lines = content.split('\n')
    improved_lines = []
    i = 0
    
    while i < len(lines):
        line = lines[i].rstrip()
        
        # Pattern 1: Make byte_reader const when it's only used for reading
        if re.match(r'\s*byte_reader\s+(\w+)\s*\(', line) and 'const' not in line:
            match = re.match(r'(\s*)byte_reader\s+(\w+)\s*\((.*)\)', line)
            if match:
                indent, var_name, args = match.groups()
                
                # Look ahead to see how the reader is used
                reader_uses = []
                j = i + 1
                while j < len(lines) and not lines[j].strip().startswith('TEST_CASE'):
                    if var_name in lines[j]:
                        reader_uses.append(lines[j])
                    j += 1
                
                # If reader is only used for reading (from_data calls), make it const
                only_reading = all('from_data(' in use or 'REQUIRE(' in use for use in reader_uses if var_name in use)
                if only_reading and reader_uses:
                    line = f"{indent}byte_reader const {var_name}({args})"
        
        # Pattern 2: Look for variables that can be made const
        # Variable declaration followed by immediate assignment
        var_decl_match = re.match(r'(\s*)(auto|chain::\w+|\w+::\w+|\w+)\s+(\w+)\s*;', line)
        if (var_decl_match and 'const' not in line and 
            i + 1 < len(lines)):
            
            indent, var_type, var_name = var_decl_match.groups()
            next_line = lines[i + 1].strip()
            
            # Check if the next line is an assignment to this variable
            assignment_match = re.match(rf'(\s*){re.escape(var_name)}\s*=\s*(.+);', next_line)
            if assignment_match:
                assign_indent, value = assignment_match.groups()
                
                # Look ahead to see if this variable is reassigned later
                reassigned = False
                j = i + 2
                while j < len(lines) and not lines[j].strip().startswith('TEST_CASE'):
                    if (f'{var_name} =' in lines[j] and 
                        'REQUIRE(' not in lines[j] and 
                        '==' not in lines[j] and 
                        '!=' not in lines[j]):
                        reassigned = True
                        break
                    j += 1
                
                # If not reassigned, combine declaration and assignment with const
                if not reassigned:
                    if var_type == 'auto':
                        improved_lines.append(f"{indent}auto const {var_name} = {value};")
                    else:
                        improved_lines.append(f"{indent}{var_type} const {var_name} = {value};")
                    
                    i += 1  # Skip the assignment line
                    continue
        
        # Pattern 3: Improve auto variable declarations that are already assigned
        auto_assign_match = re.match(r'(\s*)auto\s+(\w+)\s*=\s*(.+);', line)
        if auto_assign_match and 'const' not in line:
            indent, var_name, value = auto_assign_match.groups()
            
            # Look ahead to see if this variable is reassigned later
            reassigned = False
            j = i + 1
            while j < len(lines) and not lines[j].strip().startswith('TEST_CASE'):
                if (f'{var_name} =' in lines[j] and 
                    'REQUIRE(' not in lines[j] and 
                    '==' not in lines[j] and 
                    '!=' not in lines[j]):
                    reassigned = True
                    break
                j += 1
            
            # If not reassigned, make it const
            if not reassigned:
                line = f"{indent}auto const {var_name} = {value};"
        
        improved_lines.append(line)
        i += 1
    
    return '\n'.join(improved_lines)


def process_file(file_path):
    """Process a single C++ file to improve its code."""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        improved_content = improve_cpp_code(content)
        
        # Only write if there are changes
        if improved_content != content:
            # Create backup
            backup_path = str(file_path) + '.backup'
            with open(backup_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            # Write improved content
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(improved_content)
            
            print(f"Improved: {file_path}")
            return True
        else:
            print(f"No changes needed: {file_path}")
            return False
    
    except Exception as e:
        print(f"Error processing {file_path}: {e}")
        return False


def main():
    """Main function to process all relevant C++ test files."""
    if len(sys.argv) > 1:
        # Process specific files
        files_to_process = sys.argv[1:]
    else:
        # Find all test files in infrastructure and domain
        files_to_process = []
        
        # Infrastructure tests
        infra_test_dir = Path("src/infrastructure/test")
        if infra_test_dir.exists():
            files_to_process.extend(infra_test_dir.rglob("*.cpp"))
        
        # Domain tests
        domain_test_dir = Path("src/domain/test")
        if domain_test_dir.exists():
            files_to_process.extend(domain_test_dir.rglob("*.cpp"))
    
    if not files_to_process:
        print("No files to process")
        return
    
    processed_count = 0
    improved_count = 0
    
    for file_path in files_to_process:
        processed_count += 1
        if process_file(file_path):
            improved_count += 1
    
    print(f"\nProcessed {processed_count} files, improved {improved_count} files")
    if improved_count > 0:
        print("Backup files created with .backup extension")


if __name__ == "__main__":
    main()
